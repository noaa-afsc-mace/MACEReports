#' @title get_interpolated_color_bins
#'
#' @description Return binned abundance data for plotting interpolated values with greater contrast. This is a wrapper around
#' the \link[classInt:classIntervals]{classInt::classIntervals} function to make it easier to return binned color values.
#' @param z a vector of abundance values
#' @param n_bins the number of bins you'd like to return; default is 9. This is ignored if style 'log10'.
#' @param style the algorithm used in binning; default is 'log10', which places abundance values in log10 bins; 'kmeans' also produces good results.
#' @param nice_labels return label values in linear (vs log) space that are formatted for use on plots; this is meant to be #' used in conjunction with values generated by \code{get_interpolated_plot_vals}, which return log10 units.
#'
#' @examples
#'
#' prediction_values = rnorm(100, mean = 1e5, sd = 1e4)
#'
#' #bin data using default values (only z is required)
#' prediction_bins = get_interpolated_color_bins(z = prediction_values)
#'
#' #or experiment with other bins
#' prediction_bins = get_interpolated_color_bins(z = prediction_values, n_bins = 5)
#'
#' #any algorithm used by \code{classInt::classIntervals} can be used if kmeans isn't working for you:
#' prediction_bins = get_interpolated_color_bins(z = prediction_values, n_bins = 5, style = 'jenks')
#'
#' @author Mike Levine
#' @export
get_interpolated_color_bins = function(z,
                               n_bins = 9,
                               style = 'log10',
                               nice_labels = TRUE){

  #for most breaks, we'll rely on classInt::classIntervals
  if (style != 'log10'){

    #for reproducibility
    set.seed(129)
    breaks_list = classInt::classIntervals(round(z, digits = 2), n = n_bins, style = style, warnLargeN = FALSE)

  }

  #unless user requested 'log10' style; this is a manaully created division along by log10-sized bins
  if (style == 'log10'){

    #note that this sequence starts at below lowest z value simply to be at a greater range than any input data.
    log10_breaks = c(floor(min(z)), seq(2, ceiling(max(z)), 1))

    #add a few more breaks in the biggest bins
    upper_1 = log10((10^log10_breaks[length(log10_breaks)- 1])/ 2)
    upper_2 = log10((10^log10_breaks[length(log10_breaks)- 2])/ 2)

    #if there's a huge upper category, break it into two bins
    if (10^max(z)  > 10^(log10_breaks[length(log10_breaks)])/2){
      upper_3 = log10((10^log10_breaks[length(log10_breaks)])/ 2)

      log10_breaks = c(log10_breaks, upper_1, upper_2, upper_3)

    }

    if (!(10^max(z)  > 10^(log10_breaks[length(log10_breaks)])/2)){

      log10_breaks = c(log10_breaks, upper_1, upper_2)

    }

    #sort the breaks
    log10_breaks = sort(log10_breaks)

    #and use them to divide bins
    breaks_list = classInt::classIntervals(z, style = 'fixed', fixedBreaks = log10_breaks)

  }

  #return nicer labels if requested
  if(!is.null(nice_labels) & nice_labels == TRUE){

    #get the low/high values at each position
    lows = c()
    highs = c()
    for (i in 1:(length(breaks_list$brks)-1)){

      lows = rbind(lows, breaks_list$brks[i])
      highs = rbind(highs, breaks_list$brks[i + 1])

    }

    #combine as a dataframe
    lims = data.frame('lows' = lows,
                      'highs' = highs)

    #convert to linear space + round
    lims$lows = trimws(format(round(10^lims$lows, digits = 0), scientific = FALSE, big.mark = ','))
    lims$highs = trimws(format(round(10^lims$highs, digits = 0),  scientific = FALSE, big.mark = ','))

    #combine labels
    lims$label = paste0(lims$lows, '-', lims$highs)

    #edit the lowermost and uppermost bins to be '<', '>'
    lims$label[1] = paste0('< ', stringr::str_split(lims$label[1], '-')[[1]][[2]])
    lims$label[nrow(lims)] = paste0('> ', stringr::str_split(lims$label[nrow(lims)], '-')[[1]][[1]])

    #map the breaks onto the data
    plot_val = cut(round(z, digits = 2),
                   breaks = breaks_list$brks, include.lowest = TRUE, right = TRUE, labels = lims$label)

  }

  if (is.null(nice_labels)){

  #map the breaks onto the data
  plot_val = cut(round(z, digits = 2),
                 breaks = breaks_list$brks, include.lowest = TRUE, right = TRUE)

  }

  #return the breaks
  return(plot_val)

}
