#' @title Return logical breaks that can be used to plot abundance values
#'
#' @description Return binned abundance data for plotting interpolated values with greater contrast. This is a wrapper around
#' the \link[classInt:classIntervals]{classInt::classIntervals} function to make it easier to return binned color values.
#' @param z a vector of abundance values
#' @param n_bins the number of bins you'd like to return; default is 9. This is ignored if style 'log10'.
#' @param style the algorithm used in binning; default is 'log10', which places abundance values in log10 bins; 'kmeans' also produces good results.
#' @param nice_labels return label values in linear (vs log) space that are formatted for use on plots; this is meant to be #' used in conjunction with values generated by \code{get_interpolated_plot_vals}, which return log10 units.
#'
#' @examples
#' \dontrun{
#' # Get some interpolated plot values
#' shelikof_xyz <- shelikof_biomass %>%
#'   filter(year == 2021) %>%
#'   group_by(INTERVAL, START_LATITUDE, START_LONGITUDE) %>%
#'   summarize(
#'     BIOMASS = sum(BIOMASS),
#'     BIOMASS_NM2 = sum(BIOMASS_NM2)
#'   )
#'
#' interp_vals_2021 <- get_interpolated_plot_vals(x = shelikof_xyz$START_LONGITUDE,
#' y = shelikof_xyz$START_LATITUDE,
#' z = shelikof_xyz$BIOMASS,
#' resolution = 1000,
#' region = "shelikof",
#' interp_type = "universal",
#' neighborhood = 200)
#'
#' # create an sf object we can use to define the basemap extent
#' extent <- st_as_sf(interp_vals_2021, coords = c("x", "y"), crs = "EPSG:3338")
#'
#' # # Return a simple basemap with contours as the bathymetery seems too busy with interpolated maps
#' basemap <- get_basemap_layers(plot_limits_data = extent,
#' bathy = FALSE,
#' contours = c(100, 200, 1000))
#'
#' # Get the interpolated values: at a minimum, provide Z values
#' interp_vals_2021$plot_col <- get_interpolated_color_bins(z = interp_vals_2021$z)
#'
#' basemap +
#'   geom_raster(data = interp_vals_2021, aes(x = x, y = y, fill = plot_col)) +
#'   scale_fill_viridis_d(option = "magma")
#' }
#' @author Mike Levine
#' @export
get_interpolated_color_bins <- function(z,
                                        n_bins = 9,
                                        style = "log10",
                                        nice_labels = TRUE) {
  # for most breaks, we'll rely on classInt::classIntervals
  if (style != "log10") {
    # for reproducibility
    set.seed(129)
    breaks_list <- classInt::classIntervals(round(z, digits = 2), n = n_bins, style = style, warnLargeN = FALSE)
  }

  # unless user requested 'log10' style; this is a manaully created division along by log10-sized bins
  if (style == "log10") {
    # note that this sequence starts at below lowest z value simply to be at a greater range than any input data.
    log10_breaks <- c(floor(min(z)), seq(2, ceiling(max(z)), 1))

    # add a few more breaks in the biggest bins
    upper_1 <- log10((10^log10_breaks[length(log10_breaks) - 1]) / 2)
    upper_2 <- log10((10^log10_breaks[length(log10_breaks) - 2]) / 2)

    # if there's a huge upper category, break it into two bins
    if (10^max(z) > 10^(log10_breaks[length(log10_breaks)]) / 2) {
      upper_3 <- log10((10^log10_breaks[length(log10_breaks)]) / 2)

      log10_breaks <- c(log10_breaks, upper_1, upper_2, upper_3)
    }

    if (!(10^max(z) > 10^(log10_breaks[length(log10_breaks)]) / 2)) {
      log10_breaks <- c(log10_breaks, upper_1, upper_2)
    }

    # sort the breaks
    log10_breaks <- sort(log10_breaks)

    # to be safe: check for any duplicated breaks
    log10_breaks <- log10_breaks[!duplicated(log10_breaks)]

    # and use them to divide bins
    breaks_list <- classInt::classIntervals(z, style = "fixed", fixedBreaks = log10_breaks)
  }

  # return nicer labels if requested
  if (!is.null(nice_labels) & nice_labels == TRUE) {
    # get the low/high values at each position
    lows <- c()
    highs <- c()
    for (i in 1:(length(breaks_list$brks) - 1)) {
      lows <- rbind(lows, breaks_list$brks[i])
      highs <- rbind(highs, breaks_list$brks[i + 1])
    }

    # combine as a dataframe
    lims <- data.frame(
      "lows" = lows,
      "highs" = highs
    )

    # convert to linear space + round
    lims$lows <- trimws(format(round(10^lims$lows, digits = 0), scientific = FALSE, big.mark = ","))
    lims$highs <- trimws(format(round(10^lims$highs, digits = 0), scientific = FALSE, big.mark = ","))

    # combine labels
    lims$label <- paste0(lims$lows, "-", lims$highs)

    # edit the lowermost and uppermost bins to be '<', '>'
    lims$label[1] <- paste0("< ", stringr::str_split(lims$label[1], "-")[[1]][[2]])
    lims$label[nrow(lims)] <- paste0("> ", stringr::str_split(lims$label[nrow(lims)], "-")[[1]][[1]])

    # map the breaks onto the data
    plot_val <- cut(round(z, digits = 2),
      breaks = breaks_list$brks, include.lowest = TRUE, right = TRUE, labels = lims$label
    )
  } else {
    # map the breaks onto the data
    plot_val <- cut(round(z, digits = 2),
      breaks = breaks_list$brks, include.lowest = TRUE, right = TRUE
    )
  }

  # return the breaks
  return(plot_val)
}
